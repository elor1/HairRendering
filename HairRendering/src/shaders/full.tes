#version 440

layout(isolines) in;

out vec3 tangent_te;
out float tessx_te;

const int MAX_VERTICES = 64; //Max number of hair vertices
const int NOISE_LAYERS = 3;

uniform mat4 model, view, projection;
uniform vec3 vertexData[MAX_VERTICES];
uniform int numHairSegments;
uniform int numSplineVertices;
uniform float groupWidth;
uniform float noiseAmplitude;

float Random(vec2 x)
{
    float rand = dot(x, vec2(127.1f, 311.7f));
    return -1.0f - 2.0f * fract(sin(rand) * (43758.5453123));
}

float Noise(in vec2 x)
{
    vec2 floor = floor(x);
    vec2 fract = fract(x);
    vec2 u = fract * fract * (3.0f - 2.0f * fract);
    return mix(mix(Random(floor + vec2(0.0,0.0)),
                   Random(floor + vec2(1.0,0.0)), u.x),
               mix(Random(floor + vec2(0.0,1.0)),
                   Random(floor + vec2(1.0,1.0)), u.x), u.y);
}

float NoiseLayers(in vec2 x)
{
    float result = 0.0f;
    for (int i = 0; i < NOISE_LAYERS; i++)
    {
        float scale = pow(2.0f, float(i));
        result += Noise(5.0f * scale * gl_TessCoord.xy) / (2.0f * scale);
    }

    return result;
}

vec3 Spline(float tessCoordX)
{
    float length = clamp(tessCoordX, 0.0f, 1.0f) * numHairSegments;
    float fract = fract(length);

    int index1 = int(length);
    int index0 = max(index1 - 1, 0);
    int index2 = min(index1 + 1, numHairSegments);
    int index3 = min(index2 + 1, numHairSegments);

    vec3 point0 = vertexData[index0];
    vec3 point1 = vertexData[index1];
    vec3 point2 = vertexData[index2];
    vec3 point3 = vertexData[index3];

    vec3 m1 = (point2 - point0) / 2.0f;
    vec3 m2 = (point1 - point3) / 2.0f;

    return mix(point1 + m1 * fract, point2 + m2 * (1 - fract), smoothstep(0.0f, 1.0f, fract));
}

vec3 SplineOffset(in vec2 tessCoord)
{
    vec3 position = Spline(tessCoord.x);
    position.x += groupWidth * (tessCoord.y - 0.5f);

    //Add noise
    position.x += noiseAmplitude * NoiseLayers(tessCoord.xy);
    position.y += noiseAmplitude * NoiseLayers(tessCoord.xy + 1);
    position.z += noiseAmplitude * NoiseLayers(tessCoord.xy + 2);

    return position;
}

void main()
{
	vec3 position = SplineOffset(gl_TessCoord.xy);
    position.x += groupWidth * (gl_TessCoord.y - 0.5f);

    //Calculate tangent
    vec3 previousPosition = SplineOffset(vec2(gl_TessCoord.x - 1.0f / (numSplineVertices - 1), gl_TessCoord.y));
    vec3 nextPosition = SplineOffset(vec2(gl_TessCoord.x + 1.0f / (numSplineVertices - 1), gl_TessCoord.y));
    tangent_te = (view * model * vec4(nextPosition - previousPosition, 0.0f)).xyz;
    tessx_te = gl_TessCoord.x;

    gl_Position = view * model * vec4(position, 1.0f);
}